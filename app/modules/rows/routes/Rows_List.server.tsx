import { ActionFunction, LoaderFunctionArgs, redirect } from "react-router";
import { RowsApi } from "~/utils/api/.server/RowsApi";
import { getEntityPermission } from "~/utils/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "~/utils/helpers/.server/PermissionsService";
import { EntitiesApi } from "~/utils/api/.server/EntitiesApi";
import UrlUtils from "~/utils/app/UrlUtils";
import { EntityViewsApi } from "~/utils/api/.server/EntityViewsApi";
import { getEntityView, deleteEntityView } from "~/utils/db/entities/entityViews.db.server";
import { MetaTagsDto } from "~/application/dtos/seo/MetaTagsDto";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "~/modules/metrics/services/.server/MetricTracker";
import FormulaService from "~/modules/formulas/services/.server/FormulaService";
import { EntityView } from "@prisma/client";
import { getRowsInIds } from "~/utils/db/entities/rows.db.server";
import RowHelper from "~/utils/helpers/RowHelper";

export namespace Rows_List {
  export type LoaderData = {
    meta: MetaTagsDto;
    rowsData: RowsApi.GetRowsData;
    routes: EntitiesApi.Routes;
  };
  export const loader = async ({ request, params }: LoaderFunctionArgs) => {
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
    const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params });
    await time(verifyUserHasPermission(request, getEntityPermission(entity, "view"), tenantId), "verifyUserHasPermission");
    if (!entity.isAutogenerated || entity.type === "system") {
      throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
    }
    const rowsData = await time(
      RowsApi.getAll({
        entity,
        tenantId,
        userId,
        urlSearchParams: new URL(request.url).searchParams,
        time,
      }),
      "RowsApi.getAll"
    );
    await time(
      FormulaService.trigger({ trigger: "BEFORE_LISTED", rows: rowsData.items, entity: rowsData.entity, session: { tenantId, userId }, t }),
      "FormulaService.trigger.BEFORE_LISTED"
    );
    const data: LoaderData = {
      meta: [{ title: `${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
      rowsData,
      routes: EntitiesApi.getNoCodeRoutes({ request, params }),
    };
    return Response.json(data, { headers: getServerTimingHeader() });
  };

  export type ActionData = {
    success?: string;
    error?: string;
    updatedView?: EntityView;
    rowsDeleted?: string[];
  };
  export const action: ActionFunction = async ({ request, params }) => {
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
    const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params });
    const action = form.get("action")?.toString() ?? "";
    if (action === "view-create") {
      try {
        const view = await time(EntityViewsApi.createFromForm({ entity, form, createdByUserId: userId }), "EntityViewsApi.createFromForm");
        return redirect(new URL(request.url, request.url).pathname + "?v=" + view.name, { headers: getServerTimingHeader() });
      } catch (e: any) {
        return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
      }
    } else if (action === "view-edit" || action === "view-delete") {
      const id = form.get("id")?.toString() ?? "";
      const item = await time(getEntityView(id), "getEntityView");
      if (!item) {
        return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
      }
      try {
        if (action === "view-edit") {
          const updatedView = await time(EntityViewsApi.updateFromForm({ entity, item, form }), "EntityViewsApi.updateFromForm");
          return Response.json({ updatedView }, { headers: getServerTimingHeader() });
        } else {
          await time(deleteEntityView(item.id), "deleteEntityView");
          return redirect(new URL(request.url, request.url).pathname + "?v=", { headers: getServerTimingHeader() });
        }
      } catch (e: any) {
        return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
      }
    } else if (["move-up", "move-down"].includes(action)) {
      const id = form.get("id")?.toString() ?? "";
      await time(
        RowsApi.changeOrder(id, {
          target: action === "move-up" ? "up" : "down",
        }),
        "RowsApi.changeOrder"
      );
      return Response.json({ success: true, headers: getServerTimingHeader() });
    } else if (action === "board-move") {
      try {
        const id = form.get("id")?.toString() ?? "";
        const property = form.get("property")?.toString() ?? "";
        const value = form.get("value")?.toString() ?? "";
        if (!id || !property) {
          return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
        }
        const row = await RowsApi.get(id, { entity, tenantId, userId, time });
        if (!row.item) {
          return Response.json({ error: t("shared.notFound") }, { status: 404, headers: getServerTimingHeader() });
        }
        const rowValues = RowHelper.getRowPropertiesFromForm({
          entity,
          existing: row.item,
          values: [{ name: property, value }],
          options: { skipValidation: true },
        });
        const updated = await time(
          RowsApi.update(id, {
            entity,
            tenantId,
            userId,
            rowValues,
            checkPermissions: false,
          }),
          "RowsApi.update.board-move"
        );
        return Response.json({ success: true, updated }, { headers: getServerTimingHeader() });
      } catch (e: any) {
        return Response.json({ error: e.message }, { status: 200, headers: getServerTimingHeader() });
      }
    } else if (action === "bulk-delete") {
      if (!entity.hasBulkDelete) {
        return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
      }
      const rowIds = form.getAll("rowIds[]") as string[];
      try {
        const rows = await getRowsInIds(rowIds);
        const inexistentRows = rowIds.filter((id) => !rows.find((f) => f.id === id));
        if (inexistentRows.length > 0) {
          return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
        }
        const rowsDeleted: string[] = [];
        await Promise.all(
          rows.map(async (row) => {
            const deleted = await RowsApi.del(row.id, { entity, tenantId, userId });
            rowsDeleted.push(deleted.id);
          })
        );
        return Response.json({ success: t("shared.deleted"), rowsDeleted }, { headers: getServerTimingHeader() });
      } catch (e: any) {
        return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
      }
    } else {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }
  };
}
