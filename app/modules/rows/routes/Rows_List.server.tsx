import { ActionFunction, LoaderFunctionArgs, redirect } from "react-router";
import { RowsApi } from "~/utils/api/.server/RowsApi";
import { getEntityPermission } from "~/utils/helpers/PermissionsHelper";
import { verifyUserHasPermission } from "~/utils/helpers/.server/PermissionsService";
import { EntitiesApi } from "~/utils/api/.server/EntitiesApi";
import UrlUtils from "~/utils/app/UrlUtils";
import { EntityViewsApi } from "~/utils/api/.server/EntityViewsApi";
import { getEntityView, deleteEntityView } from "~/utils/db/entities/entityViews.db.server";
import { MetaTagsDto } from "~/application/dtos/seo/MetaTagsDto";
import RowsRequestUtils from "../utils/RowsRequestUtils";
import { createMetrics } from "~/modules/metrics/services/.server/MetricTracker";
import FormulaService from "~/modules/formulas/services/.server/FormulaService";
import { EntityView } from "@prisma/client";
import { getRowsInIds } from "~/utils/db/entities/rows.db.server";
import RowHelper from "~/utils/helpers/RowHelper";

export namespace Rows_List {
  export type LoaderData = {
    meta: MetaTagsDto;
    rowsData: RowsApi.GetRowsData;
    routes: EntitiesApi.Routes;
  };
  export const loader = async ({ request, params }: LoaderFunctionArgs) => {
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
    const { t, userId, tenantId, entity } = await RowsRequestUtils.getLoader({ request, params });
    await time(verifyUserHasPermission(request, getEntityPermission(entity, "view"), tenantId), "verifyUserHasPermission");
    if (!entity.isAutogenerated || entity.type === "system") {
      throw redirect(tenantId ? UrlUtils.currentTenantUrl(params, "404") : "/404");
    }
    const rowsData = await time(
      RowsApi.getAll({
        entity,
        tenantId,
        userId,
        urlSearchParams: new URL(request.url).searchParams,
        time,
      }),
      "RowsApi.getAll"
    );
    await time(
      FormulaService.trigger({ trigger: "BEFORE_LISTED", rows: rowsData.items, entity: rowsData.entity, session: { tenantId, userId }, t }),
      "FormulaService.trigger.BEFORE_LISTED"
    );
    const data: LoaderData = {
      meta: [{ title: `${t(entity.titlePlural)} | ${process.env.APP_NAME}` }],
      rowsData,
      routes: EntitiesApi.getNoCodeRoutes({ request, params }),
    };
    return Response.json(data, { headers: getServerTimingHeader() });
  };

  export type ActionData = {
    success?: string;
    error?: string;
    updatedView?: EntityView;
    rowsDeleted?: string[];
  };

  type Handler = () => Promise<Response>;

  const isInvalidField = (value: FormDataEntryValue | null) => typeof value === "object" && value !== null;
  const getStringField = (form: FormData, field: string, t: any) => {
    const value = form.get(field);
    if (isInvalidField(value)) {
      throw Response.json({ error: t("shared.invalidForm") }, { status: 400 });
    }
    return value?.toString() ?? "";
  };

  export const action: ActionFunction = async ({ request, params }) => {
    const { time, getServerTimingHeader } = await createMetrics({ request, params }, `[Rows_List] ${params.entity}`);
    const { t, userId, tenantId, entity, form } = await RowsRequestUtils.getAction({ request, params });
    const actionValue = form.get("action");
    const action = typeof actionValue === "string" ? actionValue : "";
    const handlers: Record<string, Handler> = {
      "view-create": async () => {
        const view = await time(EntityViewsApi.createFromForm({ entity, form, createdByUserId: userId }), "EntityViewsApi.createFromForm");
        return redirect(new URL(request.url, request.url).pathname + "?v=" + view.name, { headers: getServerTimingHeader() });
      },
      "view-edit": async () => {
        const id = getStringField(form, "id", t);
        const item = await time(getEntityView(id), "getEntityView");
        if (!item) {
          return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
        }
        const updatedView = await time(EntityViewsApi.updateFromForm({ entity, item, form }), "EntityViewsApi.updateFromForm");
        return Response.json({ updatedView }, { headers: getServerTimingHeader() });
      },
      "view-delete": async () => {
        const id = getStringField(form, "id", t);
        const item = await time(getEntityView(id), "getEntityView");
        if (!item) {
          return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
        }
        await time(deleteEntityView(item.id), "deleteEntityView");
        return redirect(new URL(request.url, request.url).pathname + "?v=", { headers: getServerTimingHeader() });
      },
      "move-up": async () => {
        const id = getStringField(form, "id", t);
        await time(
          RowsApi.changeOrder(id, {
            target: "up",
          }),
          "RowsApi.changeOrder"
        );
        return Response.json({ success: true, headers: getServerTimingHeader() });
      },
      "move-down": async () => {
        const id = getStringField(form, "id", t);
        await time(
          RowsApi.changeOrder(id, {
            target: "down",
          }),
          "RowsApi.changeOrder"
        );
        return Response.json({ success: true, headers: getServerTimingHeader() });
      },
      "board-move": async () => {
        const id = getStringField(form, "id", t);
        const property = getStringField(form, "property", t);
        const value = getStringField(form, "value", t);
        if (!id || !property) {
          return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
        }
        const row = await RowsApi.get(id, { entity, tenantId, userId, time });
        if (!row.item) {
          return Response.json({ error: t("shared.notFound") }, { status: 404, headers: getServerTimingHeader() });
        }
        const rowValues = RowHelper.getRowPropertiesFromForm({
          entity,
          existing: row.item,
          values: [{ name: property, value }],
          options: { skipValidation: true },
        });
        const updated = await time(
          RowsApi.update(id, {
            entity,
            tenantId,
            userId,
            rowValues,
            checkPermissions: false,
          }),
          "RowsApi.update.board-move"
        );
        return Response.json({ success: true, updated }, { headers: getServerTimingHeader() });
      },
      "bulk-delete": async () => {
        if (!entity.hasBulkDelete) {
          return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
        }
        const rowIds = form.getAll("rowIds[]") as string[];
        const rows = await getRowsInIds(rowIds);
        const inexistentRows = rowIds.filter((id) => !rows.some((f) => f.id === id));
        if (inexistentRows.length > 0) {
          return Response.json({ error: t("shared.notFound") }, { status: 400, headers: getServerTimingHeader() });
        }
        const rowsDeleted: string[] = [];
        await Promise.all(
          rows.map(async (row) => {
            const deleted = await RowsApi.del(row.id, { entity, tenantId, userId });
            rowsDeleted.push(deleted.id);
          })
        );
        return Response.json({ success: t("shared.deleted"), rowsDeleted }, { headers: getServerTimingHeader() });
      },
    };

    const handler = handlers[action];
    if (!handler) {
      return Response.json({ error: t("shared.invalidForm") }, { status: 400, headers: getServerTimingHeader() });
    }

    try {
      return await handler();
    } catch (e: any) {
      return Response.json({ error: e.message }, { status: 400, headers: getServerTimingHeader() });
    }
  };
}
